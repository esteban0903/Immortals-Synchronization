From 13c90c7a6d03e50aa3e180a75b4728e78bbdf0c5 Mon Sep 17 00:00:00 2001
From: Sebastian Beltran <juan.beltran0518@hotmail.com>
Date: Fri, 5 Sep 2025 19:09:19 -0500
Subject: [PATCH] Implementacion de Test

---
 .../arsw/concurrency/PauseControllerTest.java | 120 ++++++++++++++
 .../FightStrategyComparisonTest.java          |  89 ++++++++++
 .../immortals/ImmortalConcurrencyTest.java    | 152 ++++++++++++++++++
 .../eci/arsw/immortals/ScoreBoardTest.java    |  75 +++++++++
 4 files changed, 436 insertions(+)
 create mode 100644 src/test/java/edu/eci/arsw/concurrency/PauseControllerTest.java
 create mode 100644 src/test/java/edu/eci/arsw/immortals/FightStrategyComparisonTest.java
 create mode 100644 src/test/java/edu/eci/arsw/immortals/ImmortalConcurrencyTest.java
 create mode 100644 src/test/java/edu/eci/arsw/immortals/ScoreBoardTest.java

diff --git a/src/test/java/edu/eci/arsw/concurrency/PauseControllerTest.java b/src/test/java/edu/eci/arsw/concurrency/PauseControllerTest.java
new file mode 100644
index 0000000..79b23df
--- /dev/null
+++ b/src/test/java/edu/eci/arsw/concurrency/PauseControllerTest.java
@@ -0,0 +1,120 @@
+package edu.eci.arsw.concurrency;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.DisplayName;
+import static org.junit.jupiter.api.Assertions.*;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * Tests enfocados en verificar el comportamiento del PauseController
+ * en escenarios de concurrencia.
+ */
+class PauseControllerTest {
+
+    @Test
+    @DisplayName("PauseController debe permitir pausar y reanudar hilos correctamente")
+    @Timeout(value = 5, unit = TimeUnit.SECONDS)
+    void shouldPauseAndResumeThreadsCorrectly() throws InterruptedException {
+        var controller = new PauseController();
+        controller.setTotalThreads(2);
+
+        var counter = new AtomicInteger(0);
+        var startLatch = new CountDownLatch(2);
+
+        Thread worker1 = new Thread(() -> {
+            try {
+                startLatch.countDown();
+                for (int i = 0; i < 100; i++) {
+                    controller.awaitIfPaused();
+                    counter.incrementAndGet();
+                    Thread.sleep(1);
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        });
+
+        Thread worker2 = new Thread(() -> {
+            try {
+                startLatch.countDown();
+                for (int i = 0; i < 100; i++) {
+                    controller.awaitIfPaused();
+                    counter.incrementAndGet();
+                    Thread.sleep(1);
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        });
+
+        worker1.start();
+        worker2.start();
+
+        startLatch.await();
+        Thread.sleep(50);
+
+        controller.pause();
+        assertTrue(controller.paused());
+
+        controller.waitUntilAllPaused();
+
+        int countWhenPaused = counter.get();
+        Thread.sleep(100);
+        assertEquals(countWhenPaused, counter.get(),
+                "El contador no debería cambiar mientras está pausado");
+
+        controller.resume();
+        assertFalse(controller.paused());
+
+        Thread.sleep(50);
+        assertTrue(counter.get() > countWhenPaused,
+                "El contador debería incrementar después de reanudar");
+
+        worker1.join();
+        worker2.join();
+    }
+
+    @Test
+    @DisplayName("PauseController debe manejar correctamente múltiples pausas y reanudaciones")
+    @Timeout(value = 5, unit = TimeUnit.SECONDS)
+    void shouldHandleMultiplePauseResumeCycles() throws InterruptedException {
+        var controller = new PauseController();
+        controller.setTotalThreads(1);
+
+        var executionSteps = new AtomicInteger(0);
+
+        Thread worker = new Thread(() -> {
+            try {
+                for (int i = 0; i < 20; i++) {
+                    controller.awaitIfPaused();
+                    executionSteps.incrementAndGet();
+                    Thread.sleep(10);
+                }
+            } catch (InterruptedException e) {
+                Thread.currentThread().interrupt();
+            }
+        });
+
+        worker.start();
+        Thread.sleep(30);
+
+        for (int cycle = 0; cycle < 3; cycle++) {
+            controller.pause();
+            controller.waitUntilAllPaused();
+
+            int stepsBefore = executionSteps.get();
+            Thread.sleep(50);
+            assertEquals(stepsBefore, executionSteps.get(),
+                    "No debería ejecutarse mientras está pausado");
+
+            controller.resume();
+            Thread.sleep(30);
+        }
+
+        worker.join();
+        assertTrue(executionSteps.get() > 0, "Debería haber ejecutado algunos pasos");
+    }
+}
diff --git a/src/test/java/edu/eci/arsw/immortals/FightStrategyComparisonTest.java b/src/test/java/edu/eci/arsw/immortals/FightStrategyComparisonTest.java
new file mode 100644
index 0000000..83a5278
--- /dev/null
+++ b/src/test/java/edu/eci/arsw/immortals/FightStrategyComparisonTest.java
@@ -0,0 +1,89 @@
+package edu.eci.arsw.immortals;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.DisplayName;
+import static org.junit.jupiter.api.Assertions.*;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Tests comparativos entre las estrategias NAIVE y ORDERED.
+ * Enfocados en detectar diferencias de comportamiento y estabilidad.
+ */
+class FightStrategyComparisonTest {
+
+    private static final int INITIAL_HEALTH = 100;
+    private static final int DAMAGE = 10;
+    private static final int TEST_TIMEOUT_SECONDS = 8;
+
+    @Test
+    @DisplayName("La estrategia ORDERED debe ser más estable que NAIVE bajo concurrencia")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void orderedStrategyShouldBeMoreStableThanNaive() throws InterruptedException {
+        try (var orderedManager = new ImmortalManager(4, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            orderedManager.start();
+            Thread.sleep(200);
+            orderedManager.stop();
+
+            for (Immortal immortal : orderedManager.populationSnapshot()) {
+                assertTrue(immortal.getHealth() >= 0,
+                        "ORDERED: Ningún inmortal debería tener salud negativa");
+            }
+
+            long orderedFights = orderedManager.scoreBoard().totalFights();
+            assertTrue(orderedFights > 0, "ORDERED: Deberían haber ocurrido peleas");
+        }
+
+        try (var naiveManager = new ImmortalManager(2, INITIAL_HEALTH, DAMAGE, FightStrategy.NAIVE)) {
+            naiveManager.start();
+            Thread.sleep(100);
+            naiveManager.stop();
+
+            long naiveFights = naiveManager.scoreBoard().totalFights();
+            assertTrue(naiveFights >= 0, "NAIVE: Debería poder ejecutar (aunque sea con deadlock potencial)");
+        }
+    }
+
+    @Test
+    @DisplayName("La estrategia ORDERED debe soportar pause/resume sin deadlocks")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void orderedStrategyShouldSupportPauseResumeWithoutDeadlocks() throws InterruptedException {
+        try (var orderedManager = new ImmortalManager(3, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            orderedManager.start();
+            Thread.sleep(50);
+
+            orderedManager.pause();
+            long pausedFights = orderedManager.scoreBoard().totalFights();
+
+            Thread.sleep(100);
+            assertEquals(pausedFights, orderedManager.scoreBoard().totalFights(),
+                    "ORDERED: No deberían ocurrir peleas mientras está pausado");
+
+            orderedManager.resume();
+            Thread.sleep(50);
+
+            assertTrue(orderedManager.scoreBoard().totalFights() >= pausedFights,
+                    "ORDERED: Deberían continuar las peleas después de resume");
+        }
+    }
+
+    @Test
+    @DisplayName("La creación de managers con diferentes estrategias debe funcionar correctamente")
+    void shouldCreateManagersWithDifferentStrategiesCorrectly() {
+        try (var directOrdered = new ImmortalManager(2, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED);
+                var directNaive = new ImmortalManager(2, INITIAL_HEALTH, DAMAGE, FightStrategy.NAIVE)) {
+
+            assertEquals(FightStrategy.ORDERED, directOrdered.getFightStrategy());
+            assertEquals(FightStrategy.NAIVE, directNaive.getFightStrategy());
+        }
+
+        try (var stringOrdered = new ImmortalManager(2, "ordered", INITIAL_HEALTH, DAMAGE);
+                var stringNaive = new ImmortalManager(2, "naive", INITIAL_HEALTH, DAMAGE);
+                var stringDefault = new ImmortalManager(2, "invalid", INITIAL_HEALTH, DAMAGE)) {
+
+            assertEquals(FightStrategy.ORDERED, stringOrdered.getFightStrategy());
+            assertEquals(FightStrategy.NAIVE, stringNaive.getFightStrategy());
+            assertEquals(FightStrategy.ORDERED, stringDefault.getFightStrategy());
+        }
+    }
+}
diff --git a/src/test/java/edu/eci/arsw/immortals/ImmortalConcurrencyTest.java b/src/test/java/edu/eci/arsw/immortals/ImmortalConcurrencyTest.java
new file mode 100644
index 0000000..943d76c
--- /dev/null
+++ b/src/test/java/edu/eci/arsw/immortals/ImmortalConcurrencyTest.java
@@ -0,0 +1,152 @@
+package edu.eci.arsw.immortals;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
+import org.junit.jupiter.api.DisplayName;
+import static org.junit.jupiter.api.Assertions.*;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Tests comprehensivos para el sistema de Inmortales.
+ * Enfocados en validar funcionalidad core y aspectos de concurrencia.
+ */
+class ImmortalConcurrencyTest {
+
+    private static final int INITIAL_HEALTH = 100;
+    private static final int DAMAGE = 10;
+    private static final int TEST_TIMEOUT_SECONDS = 10;
+
+    @Test
+    @DisplayName("El manager debe inicializar correctamente la población de inmortales")
+    void shouldInitializeImmortalPopulationCorrectly() {
+        try (var manager = new ImmortalManager(5, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            assertEquals(5, manager.populationSnapshot().size());
+            assertEquals(5 * INITIAL_HEALTH, manager.totalHealth());
+            assertEquals(5, manager.aliveCount());
+            assertEquals(FightStrategy.ORDERED, manager.getFightStrategy());
+            assertFalse(manager.isRunning());
+        }
+    }
+
+    @Test
+    @DisplayName("Los inmortales deben poder pausar y reanudar correctamente")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void shouldPauseAndResumeCorrectly() throws InterruptedException {
+        try (var manager = new ImmortalManager(4, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            manager.start();
+            assertTrue(manager.isRunning());
+
+            Thread.sleep(50);
+
+            manager.pause();
+            long healthAtPause = manager.totalHealth();
+            long fightsAtPause = manager.scoreBoard().totalFights();
+
+            Thread.sleep(100);
+            assertEquals(healthAtPause, manager.totalHealth());
+            assertEquals(fightsAtPause, manager.scoreBoard().totalFights());
+
+            manager.resume();
+            Thread.sleep(50);
+
+            manager.stop();
+            assertFalse(manager.isRunning());
+        }
+    }
+
+    @Test
+    @DisplayName("Las peleas ordenadas deben seguir las reglas de combate correctamente")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void shouldFollowOrderedFightRulesCorrectly() throws InterruptedException {
+        try (var manager = new ImmortalManager(3, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            long initialTotalHealth = manager.totalHealth();
+
+            manager.start();
+            Thread.sleep(200);
+            manager.stop();
+
+            long finalTotalHealth = manager.totalHealth();
+            long fightsOccurred = manager.scoreBoard().totalFights();
+
+            assertTrue(fightsOccurred > 0, "Deberían haber ocurrido peleas");
+
+            assertTrue(finalTotalHealth < initialTotalHealth,
+                    "La salud total debería disminuir debido a las reglas de combate (atacante +DAMAGE/2, oponente -DAMAGE)");
+
+            for (Immortal immortal : manager.populationSnapshot()) {
+                assertTrue(immortal.getHealth() >= 0,
+                        "Ningún inmortal debería tener salud negativa");
+            }
+        }
+    }
+
+    @Test
+    @DisplayName("El ScoreBoard debe contar peleas de forma thread-safe")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void shouldCountFightsThreadSafely() throws InterruptedException {
+        try (var manager = new ImmortalManager(6, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            manager.start();
+            Thread.sleep(300);
+            manager.pause();
+
+            long fightCount = manager.scoreBoard().totalFights();
+            assertTrue(fightCount > 0, "Deberían haber ocurrido peleas");
+
+            for (int i = 0; i < 10; i++) {
+                assertEquals(fightCount, manager.scoreBoard().totalFights(),
+                        "El contador de peleas debe ser consistente");
+            }
+
+            manager.stop();
+        }
+    }
+
+    @Test
+    @DisplayName("Los inmortales deben terminar correctamente al recibir stop")
+    @Timeout(value = TEST_TIMEOUT_SECONDS, unit = TimeUnit.SECONDS)
+    void shouldStopGracefully() throws InterruptedException {
+        try (var manager = new ImmortalManager(4, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            manager.start();
+            assertTrue(manager.isRunning());
+
+            Thread.sleep(100);
+
+            manager.stop();
+
+            assertFalse(manager.isRunning());
+
+            Thread.sleep(100);
+
+            for (Immortal immortal : manager.populationSnapshot()) {
+                assertFalse(immortal.isImmortalAlive());
+            }
+        }
+    }
+
+    @Test
+    @DisplayName("AutoCloseable debe funcionar correctamente")
+    void shouldCloseCorrectly() throws Exception {
+        try (var manager = new ImmortalManager(3, INITIAL_HEALTH, DAMAGE, FightStrategy.ORDERED)) {
+            manager.start();
+            assertTrue(manager.isRunning());
+
+        }
+
+    }
+
+    @Test
+    @DisplayName("El parsing de estrategias debe funcionar correctamente")
+    void shouldParseStrategiesCorrectly() {
+        try (var naiveManager = new ImmortalManager(2, "naive", INITIAL_HEALTH, DAMAGE)) {
+            assertEquals(FightStrategy.NAIVE, naiveManager.getFightStrategy());
+        }
+
+        try (var orderedManager = new ImmortalManager(2, "ordered", INITIAL_HEALTH, DAMAGE)) {
+            assertEquals(FightStrategy.ORDERED, orderedManager.getFightStrategy());
+        }
+
+        try (var unknownManager = new ImmortalManager(2, "unknown", INITIAL_HEALTH, DAMAGE)) {
+            assertEquals(FightStrategy.ORDERED, unknownManager.getFightStrategy());
+        }
+    }
+}
diff --git a/src/test/java/edu/eci/arsw/immortals/ScoreBoardTest.java b/src/test/java/edu/eci/arsw/immortals/ScoreBoardTest.java
new file mode 100644
index 0000000..6850b61
--- /dev/null
+++ b/src/test/java/edu/eci/arsw/immortals/ScoreBoardTest.java
@@ -0,0 +1,75 @@
+package edu.eci.arsw.immortals;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.DisplayName;
+import static org.junit.jupiter.api.Assertions.*;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Tests para verificar la thread-safety del ScoreBoard.
+ */
+class ScoreBoardTest {
+
+    @Test
+    @DisplayName("ScoreBoard debe ser thread-safe bajo concurrencia alta")
+    void shouldBeThreadSafeUnderHighConcurrency() throws InterruptedException {
+        var scoreBoard = new ScoreBoard();
+        int numberOfThreads = 10;
+        int fightsPerThread = 1000;
+
+        var startLatch = new CountDownLatch(numberOfThreads);
+        var executor = Executors.newFixedThreadPool(numberOfThreads);
+
+        for (int i = 0; i < numberOfThreads; i++) {
+            executor.submit(() -> {
+                startLatch.countDown();
+                try {
+                    startLatch.await();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                    return;
+                }
+
+                for (int fight = 0; fight < fightsPerThread; fight++) {
+                    scoreBoard.recordFight();
+                }
+            });
+        }
+
+        executor.shutdown();
+        assertTrue(executor.awaitTermination(10, TimeUnit.SECONDS),
+                "Los hilos deberían terminar en tiempo razonable");
+
+        long expectedFights = (long) numberOfThreads * fightsPerThread;
+        assertEquals(expectedFights, scoreBoard.totalFights(),
+                "Deberían registrarse exactamente todas las peleas sin pérdida de datos");
+    }
+
+    @Test
+    @DisplayName("ScoreBoard debe inicializar con contador en cero")
+    void shouldInitializeWithZeroFights() {
+        var scoreBoard = new ScoreBoard();
+        assertEquals(0, scoreBoard.totalFights());
+    }
+
+    @Test
+    @DisplayName("ScoreBoard debe incrementar correctamente el contador")
+    void shouldIncrementFightCountCorrectly() {
+        var scoreBoard = new ScoreBoard();
+
+        assertEquals(0, scoreBoard.totalFights());
+
+        scoreBoard.recordFight();
+        assertEquals(1, scoreBoard.totalFights());
+
+        scoreBoard.recordFight();
+        assertEquals(2, scoreBoard.totalFights());
+
+        for (int i = 0; i < 98; i++) {
+            scoreBoard.recordFight();
+        }
+        assertEquals(100, scoreBoard.totalFights());
+    }
+}
-- 
2.39.5 (Apple Git-154)

